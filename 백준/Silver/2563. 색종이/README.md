# [Silver V] 색종이 - 2563 

[문제 링크](https://www.acmicpc.net/problem/2563) 

### 성능 요약

메모리: 1124 KB, 시간: 0 ms

### 분류

구현

### 제출 일자

2025년 11월 12일 03:17:29

### 문제 설명

<p>가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 색종이가 붙은 검은 영역의 넓이를 구하는 프로그램을 작성하시오.</p>

<p style="text-align: center;"><img alt="" src="https://u.acmicpc.net/6000c956-1b07-4913-83c3-72eda18fa1d1/Screen%20Shot%202021-06-23%20at%2012.27.04%20PM.png" style="width: 268px; height: 215px;"></p>

<p>예를 들어 흰색 도화지 위에 세 장의 검은색 색종이를 그림과 같은 모양으로 붙였다면 검은색 영역의 넓이는 260이 된다.</p>

### 입력 

 <p>첫째 줄에 색종이의 수가 주어진다. 이어 둘째 줄부터 한 줄에 하나씩 색종이를 붙인 위치가 주어진다. 색종이를 붙인 위치는 두 개의 자연수로 주어지는데 첫 번째 자연수는 색종이의 왼쪽 변과 도화지의 왼쪽 변 사이의 거리이고, 두 번째 자연수는 색종이의 아래쪽 변과 도화지의 아래쪽 변 사이의 거리이다. 색종이의 수는 100 이하이며, 색종이가 도화지 밖으로 나가는 경우는 없다</p>

### 출력 

 <p>첫째 줄에 색종이가 붙은 검은 영역의 넓이를 출력한다.</p>

### 알고리즘
<p>
100x100크기의 종이를 2차열 배열로 생각합니다. 색칠한 부분은 1, 빈 부분은 0<br>
색종이의 개수를 입력 받기.<br>
for 반복문을 종이 개수 만큼 실행하며, 색종이의 왼쪽 아래 좌표를 입력받기.<br>
안쪽 2중 for문을 사용해, (x, y)를 시작점으로 10x10 크기의 배열 영역(paper[y][x] ~ paper[y+9][x+9])을 1로 만들기.<br>
모든 색종이를 칠한 후, 다시 2중 for문으로 100x100 배열 전체를 돌며 값이 1인 칸의 총개수를 구하기.<br>
최종 값을 출력하기.<br>
</p>

### 코드설명
<p>
먼저 100x100 크기의 2차원 정수 배열 paper를 선언하고 모든 값을 0으로 초기화합니다. 0은 빈부분, 1은 색칠된 부분.<br>
총 개수인 변수 count 선언<br>

사용자에게 종이 개수 입력받음.<br>
n번 반복하는 첫 번째 for 루프에 진입. 이 루프는 각 색종이를 도화지에 붙이는 작업을 수행. 루프 안에서 scanf를 통해 색종이의 왼쪽 아래 모서리 좌표인 x와 y 값을 입력받음.<br>

안쪽에 있는 2중 for 루프. 바깥쪽 j 루프는 y부터 y+9까지, 안쪽 k 루프는 x부터 x+9까지 순회함. 이 2중 루프는 입력받은 (x, y) 좌표를 기준으로 10x10 영역에 해당하는 paper[j][k] 배열의 값을 모두 1로 덮어씀.<br>

이제 두 번째 2중 for 루프가 100x100 도화지 전체를 한 칸씩 순회함. if (paper[i][j] == 1) 조건을 통해 해당 칸이 1인지 확인하고, 만약 1이라면 count 변수의 값을 1 증가시킴.<br>

모든 칸의 확인이 끝나면, count 변수에는 1로 칠해진 칸의 총개수, 즉 총넓이가 저장됨.<br>
</p>

